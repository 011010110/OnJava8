# 第一章 对象的概念

------

> “我们没有意识到惯用语言的结构有多大的力量。可以毫不夸张地说，它通过语义反应机制奴役我们，语言表现出来并在无意识中给我们留下深刻印象的结构会自动投射到我们周围的世界。”  -- Alfred Korzybski (1930)

计算机革命的起源来自机器。编程语言就像是那台机器，它不仅是我们思维的放大工具和另一种表达媒介，更像我们思想的一部分。语言的灵感来自其他形式的表达，如写作，绘画，雕塑，动画和电影制作。编程语言就是创建应用程序的思想结构。

面向对象编程（Object-oriented programming OOP）是一种编程思维方式和编码架构。本章讲述 OOP 的基本概述。如果读者对不太理解，可先行跳过本章。等你对编程具有一定理解后，请务必再回过头来看。因为这样你才能理解面对对象编程的重要性以及如何使用它来设计你的程序。

## 抽象

所有编程语言都提供一种“抽象”的方法。从某种程度上来说，解决问题的复杂性与抽象的种类和质量直接相关。这里的“种类”意思是：你准备对什么进行抽象？汇编语言是对机器底层的一种少量抽象。后来的许多“命令式”语言（如FORTRAN，BASIC 和 C）是对汇编语言的一种抽象。与汇编语言相比，这些语言已有了长足的进步，但它们的抽象原理依然要求我们着重考虑计算机的结构，而非问题本身的结构。

在机器模型（“解决方案空间”）与实际解决的问题模型（“问题空间”）之间，程序员必须建立起一种关联。这个过程要求人们付出较大的精力，而且由于它脱离了编程语言本身的范围，造成程序代码很难编写，而且要花较大的代价进行维护。由此造成的副作用便是一门完善的“编程方法”学科。

为机器建模的另一个方法是为要解决的问题制作模型。对一些早期语言来说，如 LISP 和 APL，它们的做法是“从不同的角度观察世界”——“所有问题都归纳为列表”或“所有问题都归纳为算法”。PROLOG 则将所有
问题都归纳为决策链。对于这些语言，我们认为它们一部分是“基于约束”的编程，另一部分则是专为
处理图形符号设计的（后者被证明限制性太强）。每种方法都有自己特殊的用途，适合解决某一类的问题。只要超出了它们力所能及的范围，就会显得非常笨拙。

面向对象的程序设计在此基础上跨出了一大步，程序员可利用一些工具表达“问题空间”内的元素。由于这种
表达非常具有普遍性，所以不必受限于特定类型的问题。我们将问题空间中的元素以及它们在解决方案空间的表示物称作“对象”（Object）。当然，还有一些在问题空间没有对应的对象体。通过添加新的对象类型，程序可进行灵活的调整，以便与特定的问题配合。所以在阅读方案的描述代码时，会读到对问题进行表达的话语。与我们以前见过的相比，这无疑是一种更加灵活、更加强大的语言抽象方法。总之，OOP 允许我们根据问题来描述问题，而不是根据方案。然而，仍有一个联系途径回到计算机。每个对象都类似一台小计算机；它们有自己的状态，而且可要求它们进行特定的操作。与现实世界的“对象”或者“物体”相比，编程“对象”与它们也存在共通的地方：它们都有自己的特征和行为。

Smalltalk 作为第一种成功的面向对象程序设计语言和 Java 的基础语言，Alan Kay 总结了其五大基本特征。通过这些特征，我们可理解“纯粹”的面向对象程序设计方法是什么样的：

> 1. **万物皆对象**。你可以将对象想象成一种特殊的变量。它可以存储数据，可以在你对其“发出请求”时执行本身的操作。理论上讲，你可以从要解决的问题身上抽象出概念性的组件，然后在程序中将其表达为一个对象。
> 2. **程序是一组对象，通过消息传递来告知彼此该做什么**。要请求一个对象，你需要向该对象发送 一条消息。
> 3. **每个对象都有自己的存储空间，可容纳其他对象**。或者说，通过封装现有对象，可制作出新型对象。所以，尽管对象的概念非常简单，但在程序中却可达到任意高的复杂程度。
> 4. **每个对象都有一种类型**。根据语法，每个对象都是某个“类”的一个“实例”。其中，“类”（Class）是“类型”（Type）的同义词。一个类最重要的特征就是“能将什么消息发给它？”。
> 5. **同一类所有对象都能接收相同的消息**。这实际是别有含义的一种说法，大家不久便能理解。由于类型为“圆”（Circle）的一个对象也属于类型为“形状”（Shape）的一个对象，所以一个圆完全能接收形状消息。这意味着可让程序代码统一指挥“形状”，令其自动控制所有符合“形状”描述的对象，其中自然包括“圆”。这一特性称为对象的“可替换性”，是OOP最重要的概念之一。

Grady Booch 提供了对对象更简洁的描述：一个对象具有自己的状态，行为和身份。这意味着对象有自己的内部数据(由状态提供)、方法 (由特性提供)，并彼此区分（每个对象在内存中都有唯一的地址）。


## 接口



## 方法



## 封装



## 复用



## 继承



## 单继承



## 集合



## 生命周期



## 异常处理

